mod implementors;


pub use self::implementors::{BloomPolicy, BloomPolicyName, NoFilterPolicy};


/// The maximum length that the `flattened_key_data` slice passed to
/// [`TableFilterPolicy::create_filter`] may have, and thus also the maximum length of any
/// individual key.
///
/// Equal to [`u32::MAX`], which is just under 4 gibibytes (around 4.29 gigabytes).
pub const FILTER_KEY_LENGTH_LIMIT: u32 = u32::MAX;
/// The maximum length that the `key_offsets` slice passed to [`TableFilterPolicy::create_filter`]
/// may have.
///
/// Equal to `1 << 24`.
pub const FILTER_NUM_KEYS_LIMIT: u32 = 1 << 24;


pub trait TableFilterPolicy {
    /// The name identifying the filter policy's behavior.
    ///
    /// Should usually be a valid `&'static str`, but is not strictly required to be UTF-8.
    ///
    /// When opening a [`Table`] using a certain [`TableFilterPolicy`], this name is used to find
    /// the existing filters related to this policy.
    ///
    /// If the length of the name exceeds one GiB in length (`1 << 30`), panics may occur.
    /// A name should generally be _well_ under a kilobyte.
    ///
    /// [`Table`]: crate::table::Table
    #[must_use]
    fn name(&self) -> &'static [u8];

    /// Extends the `flattened_key_data` buffer with data based on the `key`.
    ///
    /// The key data will eventually be passed to `Self::create_filter`, along with a slice
    /// of offsets which can be used to find the boundaries between data of different keys.
    ///
    /// The `flattened_key_data` buffer must _only_ be extended; any existing contents of the
    /// buffer must not be modified, or else severe logical errors may occur. Implementors **must
    /// not** assume that the provided `flattened_key_data` is an empty `Vec`.
    fn append_key_data(&self, key: &[u8], flattened_key_data: &mut Vec<u8>);

    /// Extends the `filter` buffer with a filter corresponding to the provided flattened keys.
    ///
    /// `flattened_key_data` is the slice of data generated by calling `Self::append_key_data`
    /// once for each key.
    ///
    /// Each element of `key_offsets` is the index of the start of a key's data in
    /// `flattened_key_data`. Implementors may assume that `flattened_key_data.len() <= u32::MAX`
    /// and `key_offsets.len() <= 1 << 24`, and callers must uphold this length constraint.
    /// These limits are available as [`FILTER_KEY_LENGTH_LIMIT`] and [`FILTER_NUM_KEYS_LIMIT`],
    /// respectively.
    ///
    /// The `filter` buffer must _only_ be extended; any existing contents of the buffer must not
    /// be modified, or else severe logical errors may occur. Implementors **must not** assume
    /// that the provided `filter` is an empty `Vec`.
    ///
    /// When the generated filter is passed to `self.key_may_match()` along with a key which
    /// compares equal to one of the flattened keys, `self.key_may_match()` must return true.
    /// Additionally, if the generated filter is length 0, the filter must not match any keys.
    ///
    /// # Policy-Comparator Compatibility
    /// The `TableFilterPolicy` and [`TableComparator`] of a [`Table`] must be compatible; in
    /// particular, the `TableFilterPolicy` must ensure that generated filters match not only the
    /// exact keys for which the filter was generated, but also any key which compares equal to a
    /// key the filter was generated for. This matters if the equivalence relation of the
    /// [`TableComparator`] is looser than strict equality; that is, if bytewise-distinct
    /// keys may compare as equal.
    ///
    /// [`Table`]: crate::table::Table
    /// [`TableComparator`]: crate::comparator::TableComparator
    fn create_filter(
        &self,
        flattened_key_data: &[u8],
        key_offsets:        &[usize],
        filter:             &mut Vec<u8>,
    );

    /// Return `true` if something comparing equal to the `key` may have been among
    /// the keys for which the `filter` was generated.
    ///
    /// The `key` must be at most length `u32::MAX`. This limit is available as
    /// [`FILTER_KEY_LENGTH_LIMIT`].
    ///
    /// False positives are permissible, while false negatives are a logical error.
    /// Additionally, if the provided filter is length 0, the key must not match. (In fact,
    /// this function will not even be called in that case.)
    ///
    /// # Policy-Comparator Compatibility
    /// The `TableFilterPolicy` and [`TableComparator`] of a [`Table`] must be compatible; in
    /// particular, the `TableFilterPolicy` must ensure that generated filters match not only the
    /// exact keys for which the filter was generated, but also any key which compares equal to a
    /// key the filter was generated for. This matters if the equivalence relation of the
    /// [`TableComparator`] is looser than strict equality; that is, if bytewise-distinct
    /// keys may compare as equal.
    ///
    /// [`Table`]: crate::table::Table
    /// [`TableComparator`]: crate::comparator::TableComparator
    #[must_use]
    fn key_may_match(&self, key: &[u8], filter: &[u8]) -> bool;
    // TODO: document the compatibility requirements on Table::new and the Read/Write options
}
